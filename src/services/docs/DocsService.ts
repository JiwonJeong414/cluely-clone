// src/services/docs/DocsService.ts - Browser-only version for renderer
import type { AudioNote } from '../audio/AudioService'

export interface GoogleDoc {
  id: string
  title: string
  content?: string
  createdTime: string
  modifiedTime: string
  webViewLink: string
}

export class DocsService {
  private static instance: DocsService

  private constructor() {}

  static getInstance(): DocsService {
    if (!DocsService.instance) {
      DocsService.instance = new DocsService()
    }
    return DocsService.instance
  }

  async createDocumentFromAudioNote(audioNote: AudioNote, folderId?: string): Promise<GoogleDoc> {
    try {
      console.log('üìù Creating Google Doc from audio note:', audioNote.title)

      // Use IPC to create document in main process
      const result = await window.electronAPI.drive.createDocumentFromAudioNote({
        title: audioNote.title,
        content: this.formatAudioNoteContent(audioNote),
        folderId: folderId || undefined
      })

      if (!result.success) {
        throw new Error(result.error || 'Failed to create document')
      }

      console.log('‚úÖ Successfully created Google Doc:', result.documentId)

      return {
        id: result.documentId as string,
        title: audioNote.title,
        content: this.formatAudioNoteContent(audioNote),
        createdTime: new Date().toISOString(),
        modifiedTime: new Date().toISOString(),
        webViewLink: `https://docs.google.com/document/d/${result.documentId}/edit`
      }
    } catch (error) {
      console.error('‚ùå Error creating Google Doc:', error)
      throw error
    }
  }

  async appendToDocument(documentId: string, text: string): Promise<void> {
    try {
      const result = await window.electronAPI.drive.appendToDocument(documentId, text)
      
      if (!result.success) {
        throw new Error(result.error || 'Failed to append to document')
      }

      console.log('‚úÖ Successfully appended to Google Doc')
    } catch (error) {
      console.error('‚ùå Error appending to Google Doc:', error)
      throw error
    }
  }

  async createAudioNotesFolder(): Promise<string> {
    try {
      const result = await window.electronAPI.drive.createFolder('Audio Notes')
      
      if (!result.success) {
        throw new Error(result.error || 'Failed to create folder')
      }

      console.log('‚úÖ Created Audio Notes folder:', result.folderId)
      return result.folderId
    } catch (error) {
      console.error('‚ùå Error creating Audio Notes folder:', error)
      throw error
    }
  }

  private async moveDocumentToFolder(documentId: string, folderId: string): Promise<void> {
    try {
      const result = await window.electronAPI.drive.moveFile(documentId, folderId)
      
      if (!result.success) {
        console.error('‚ùå Error moving document to folder:', result.error)
        // Don't throw - document creation was successful
      }
    } catch (error) {
      console.error('‚ùå Error moving document to folder:', error)
      // Don't throw - document creation was successful
    }
  }

  private formatAudioNoteContent(audioNote: AudioNote): string {
    const header = `Audio Note: ${audioNote.title}\n`
    const timestamp = `Recorded: ${audioNote.timestamp.toLocaleString()}\n`
    const separator = '=' .repeat(50) + '\n\n'
    
    let content = header + timestamp + separator

    if (audioNote.content.trim()) {
      content += 'Transcription:\n'
      content += audioNote.content + '\n\n'
    }

    if (audioNote.transcriptions.length > 0) {
      content += 'Detailed Transcriptions:\n'
      content += '-'.repeat(30) + '\n'
      
      audioNote.transcriptions.forEach((transcription, index) => {
        content += `[${transcription.timestamp.toLocaleTimeString()}] `
        content += `${transcription.text}`
        if (transcription.confidence < 0.8) {
          content += ` (low confidence: ${Math.round(transcription.confidence * 100)}%)`
        }
        content += '\n\n'
      })
    }

    content += `\nGenerated by Wingman Audio Notes - ${new Date().toLocaleString()}`
    
    return content
  }

  async listRecentDocs(maxResults: number = 10): Promise<GoogleDoc[]> {
    try {
      const result = await window.electronAPI.drive.listFiles({
        pageSize: maxResults,
        orderBy: 'modifiedTime desc',
        q: "mimeType='application/vnd.google-apps.document' and trashed=false"
      })

      if (!result.success) {
        console.error('‚ùå Error listing recent docs:', result.error)
        return []
      }

      return (result.files || []).map(file => ({
        id: file.id,
        title: file.name,
        createdTime: file.modifiedTime, // Using modifiedTime as proxy
        modifiedTime: file.modifiedTime,
        webViewLink: file.webViewLink || `https://docs.google.com/document/d/${file.id}/edit`
      }))
    } catch (error) {
      console.error('‚ùå Error listing recent docs:', error)
      return []
    }
  }

  async searchDocs(query: string): Promise<GoogleDoc[]> {
    try {
      const result = await window.electronAPI.drive.listFiles({
        pageSize: 20,
        q: `mimeType='application/vnd.google-apps.document' and trashed=false and fullText contains '${query}'`
      })

      if (!result.success) {
        console.error('‚ùå Error searching docs:', result.error)
        return []
      }

      return (result.files || []).map(file => ({
        id: file.id,
        title: file.name,
        createdTime: file.modifiedTime,
        modifiedTime: file.modifiedTime,
        webViewLink: file.webViewLink || `https://docs.google.com/document/d/${file.id}/edit`
      }))
    } catch (error) {
      console.error('‚ùå Error searching docs:', error)
      return []
    }
  }
}